#summary Syntax for name juxtaposition being more general than function application.
#labels crazy

= Introduction =

Currently when we juxtapose expressions in Ωmega we get function application. Look at this: expression `map ord "Hello"`; once written you'll get value of `[Int]` and you cannot control the process. This is pretty much unavoidable, just like the type constraints that are imposed on `map` and `ord`.

We propose a new syntactical element that liberates juxtaposition from these fixed rules and allows us to assign semantics to it in a flexible fashion by the `do data` syntax.

== Why at all? ==

The most important reason is that we want to use the familiar syntax for constructing other types of data than executable code. For example we may want to write down hardware descriptions just like we do in Haskell. Of course we cannot (and usually don't want to) execute it, but capture it for later transformations.

The idea to this proposal came after digesting Wadler et al.'s paper about the _arrow calculus_. There he introduces _arrow applications_, _lambdas_ and _lets_. For each arrow, presumably.

Accidentally, in Haskell and Ωmega already use a similar mechanism, namely on the right hand side of the _::_ notation. Here juxtaposition means application of kind arrows for parameterized data types (or type families/functions).

= Details =

We'll define the syntactical sugar for our proposed language feature and define its expansion. This is basically a restricted macro expander.

== The New Syntax ==

Here is an example:

{{{
do data (,) { "Hello" (ord map) }
  where do a b = b, a
}}}

This would expand to `((map, ord), "Hello") :: (((a->b)->[a]->[b],Char->Int), [Char])`.
The `where do` clause forces the AST builder to rearrange juxtapositions to their reversals inserting a comma in between, and the `do data (,)` determines that the the type rules are according to the _pair_ type constructor.

The equation after the `do` keyword must be a syntactically valid equation, with function-like pattern on the left side.

== Lambdas? ==

This clause could change the lambda syntax' behaviour: `where do \x -> "x"` as an example of the "C" stringize operator.

== `let` definitions? ==

`where do let a = expr`

= References =

  * http://web.cecs.pdx.edu/~sheard/papers/HFL07Sheard.pdf
  * http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf