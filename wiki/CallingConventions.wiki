#summary Calling conventions are not types!
#labels Phase-Design

= Introduction =

CCs are not types but constraints on them! See also the reversed direction [http://lambda-the-ultimate.org/node/3319 types are calling conventions].

e.g. {{{'[Int :> R3, Bool :> CR0, Push Int, Push Bool] :: [Loc arch]}}}

It must satisfy the Constraint
{{{
class MachModel arch => CallingConv [Loc arch] where
  -- extract values codegen
  -- calculate (stack) area
  -- etc.
}}}

== `Loc` can be ==

  * `Push` for passing data
  * `Pop` for passing results
  * `(:>)` and `(:<)` for passing and returning in registers
  * `Cont` for multiple returns (continuations)
  * `Preserve` for declaring invariants

These are typed locations

(Should we model the PC, program counter?)

== The types ==

come from an architecture-specific universe (`PPC`, `PPC64`, `PPC64le`, `x86`, `ARM`, etc.)

Haskell types map to these, and strictness is reflected in the types.

== The registers ==

These are architecture-specific too.