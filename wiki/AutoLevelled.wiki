#summary Proposed feature of generating isomorphic datatypes at many levels in one definition.
#labels speculative,crazy,Phase-Requirements

----
= Introduction =

Consider the `Nat'` datatype:

{{{
data Nat' :: Nat ~> *0 where
  Z :: Nat' Z
  S :: Nat' n -> Nat' (S n)
}}}

where `Nat` is defined thus:
{{{
data Nat ::  *1 where
  Z :: Nat
  S :: Nat ~> Nat
}}}

This is a very common pattern of defining _singleton types_ in Ωmega. Its essence is that a _level n+1_ type is used to index an isomorphic _level n_ datatype, descending down to _level 0_.

But sometimes _n_ becomes more than 1 and the definition at the different levels gets very tedious, which is aggravated by the fact that new names must be invented for levels _n > 1_. `[`Witness the 2008 Summer School video and progress proof.`]` Our idea is to extend Ωmega's syntax with two multi-level definition constructs that hopefully take out the tedium of these patterns and make them enjoyable.

Actually there is some dogmatism here, because we want to keep the _phase distinction_, that is an intuitive virtue and has brought us so far.

----
= Proposal =

We define a syntax for _descending-levelled_ datatype definitions first. Then, in the spirit of Monnier's suggestion, add the syntax for descending-level _functions_, that is define the rule system at the highest applicable level (where no indices appear yet) and then the lower level equations are derived automatically. Finally we perform the fixpoint trick and introduce these once more but rooting at infinite level (`*∞`).

== Defining data types rooting at `*n` ==

Consider the following syntax:
{{{
data ‹Nat› where
  Z :: Nat
  S :: Nat ~> Nat
}}}

This definition is actually a multi-level definition: `Nat :: *1` and `‹Nat› :: Nat ~> *0`. The constructors are given at the highest applicable level, here: `Z :: Nat :: *1` and `S :: Nat ~> Nat :: *1`, but implicitly define the object-level ones, `‹Z› :: ‹Nat› Z :: *0` and `‹S› :: ‹Nat› n -> ‹Nat› (S n) :: *0` too.

Of course, by adding more angle brackets we can root the construction higher up in the level hierarchy.

== Defining functions at the highest level and descending ==

A common annoyance in Ωmega is that type-level functions must be defined first before object-level functions can be defining that use the former for index calculation `[`Monnier`]`. Our syntax comes in here too.

{{{
‹plus› :: ‹Nat› -> ‹Nat› -> ‹Nat›
{plus Z n} = n
{plus (S m) n} = S {plus m n}
}}}

Again, the type rule mentions the lowest applicable level, while the equations are written out for the highest applicable level. Please note that the typing invokes the descending level shorthand notation and defines the following functions:
|| *Level* || *Name* || *Signature* ||
|| `*1` || plus || `Nat ~> Nat ~> Nat` ||
|| `*0` || ‹plus› || `‹Nat› m -> ‹Nat› n -> ‹Nat› {plus m n}` ||
Also this level shorthand in the type rule is the distinguishing factor that teaches Ωmega to create a multi-level function definition.

== Rooting below `*∞`: the fixpoint ==

Now it is not always appropriate to have a finite cutoff for the indexing hierarchy, so similarly to the `*n` hierarchy we introduce a syntax for the fixpoint construction:

{{{
data «Foo» where
  Bar :: Foo
  Quux :: Foo ~> Foo
}}}

----
= Open Issues =

  * Do we need unicode to spell out these new syntactic entities?
  * How can we fit this syntax into the pun that is used to call things from value and type levels the same? Can we automatically add the angle quotes?

----
= References =
  # http://www.iro.umontreal.ca/~monnier/comp-deptypes.pdf
  # [http://www.cs.uoregon.edu/research/summerschool/summer08/video/July26Lect1.wmv Tim Sheard's 2008 Lecture Video]
  # http://code.google.com/p/omega/source/browse/trunk/tests/Progress.prg
  # http://personal.cis.strath.ac.uk/~conor/pub/she/fun/talk.pdf

----
= Examples =

== Ωmega example for `‹‹Pat››` ==

`‹‹Pat››` is like `‹Nat›` but rooted under `*2`:
{{{
data Pat :: *2 where
  Y :: Pat
  Q :: Pat ~> Pat
 deriving Nat(p)

data Pat' :: Pat ~> *1 where
  Y' :: Pat' Y
  Q' :: Pat' n ~> Pat' (Q n)
 deriving Nat(q)

data Pat'' :: Pat' p ~> *0 where
  Y :: Pat'' Y'
  Q :: Pat'' n -> Pat'' (Q' n)
 deriving Nat(r)
}}}
We can see that all is pretty regular.

Testing:
{{{
prompt> Q (Q Y)
2r : Pat'' 2q
}}}