#summary Proposed feature of generating isomorphic datatypes at many levels in one definition.
#labels speculative,crazy,Phase-Requirements

----
= Introduction =

Consider the `Nat'` datatype:

{{{
data Nat' :: Nat ~> *0 where
  Z :: Nat' Z
  S :: Nat' n -> Nat' (S n)
}}}

where `Nat` is defined thus:
{{{
data Nat ::  *1 where
  Z :: Nat
  S :: Nat ~> Nat
}}}

This is a very common pattern of defining _singleton types_ in Ωmega. Its essence is that a _level n+1_ type is used to index an isomorphic _level n_ datatype, descending down to _level 0_.

But sometimes _n_ becomes more than 1 and the definition at the different levels gets very tedious, which is aggravated by the fact that new names must be invented for levels _n > 1_. `[`Witness the 2008 Summer School video and progress proof.`]` Our idea is to extend Ωmega's syntax with two multi-level definition constructs that hopefully take out the tedium of these patterns and make them enjoyable.

Actually there is some dogmatism here, because we want to keep the _phase distinction_, that is an intuitive virtue, which has brought us so far.

----
= Proposal =

We define a syntax for _descending-levelled_ datatype definitions first. Then, in the spirit of Monnier's suggestion, add the syntax for descending-level _functions_, that is define the rule system at the highest applicable level (where no indices appear yet) and then the lower level equations are derived automatically. Finally we perform the fixpoint trick and introduce these once more but rooting at infinite level (`*∞`). `McBride` also makes an attempt to economize on typing mostly similar definitions by lifting types to the kind level. To this end he uses braces `{Type}` and accepts this as type indexes. But his setting (_she_) is pretty different as he preprocesses code annotated in such a way and emits Haskell for GHC's consumption. All lifted kinds then get replaces with `*0`.

== Defining data types rooting at `*n` ==

Consider the following syntax:
{{{
data ‹Nat› where
  Z :: Nat
  S :: Nat ~> Nat
}}}

This definition is actually a multi-level definition: `Nat :: *1` and `‹Nat› :: Nat ~> *0`. The constructors are given at the highest applicable level, here: `Z :: Nat :: *1` and `S :: Nat ~> Nat :: *1`, but implicitly define the object-level ones, `‹Z› :: ‹Nat› Z :: *0` and `‹S› :: ‹Nat› n -> ‹Nat› (S n) :: *0` too.

Of course, by adding more angle quotes we can root the construction higher up in the level hierarchy.

== Defining functions at the highest level and descending ==

A common annoyance in Ωmega is that type-level functions must be defined first before object-level functions can be defining that use the former for index calculation `[`Monnier`]`. Our syntax comes in here too.

{{{
‹plus› :: ‹Nat› -> ‹Nat› -> ‹Nat›
{plus Z n} = n
{plus (S m) n} = S {plus m n}
}}}

Again, the type rule mentions the lowest applicable level, while the equations are written out for the highest applicable level. Please note that the typing invokes the descending level shorthand notation and defines the following functions:
|| *Level* || *Name* || *Signature* ||
|| `*1` || plus || `Nat ~> Nat ~> Nat` ||
|| `*0` || ‹plus› || `‹Nat› m -> ‹Nat› n -> ‹Nat› {plus m n}` ||
Also this level shorthand in the type rule is the distinguishing factor that teaches Ωmega to create a multi-level function definition.

== Rooting below `*∞`: the fixpoint ==

Now it is not always appropriate to have a finite cutoff for the indexing hierarchy, so similarly to the `*n` hierarchy we introduce a syntax for the fixpoint construction:

{{{
data «Foo» where
  Bar :: Foo
  Quux :: Foo ~> Foo
}}}

This syntax uses the _ guillemets_-style double quotes. The types arising at any level are _infinite_, but it is certainly possible to create values `«Bar»` or `«Quux» «Bar»`.

----
= Open Issues =

  * Do we need unicode to spell out these new syntactic entities?
  * How can we fit this syntax into the pun that is used to call things from value and type levels the same? Can we automatically add the angle quotes?
  * Support the Haskell-like notation `data ‹Nat› = Z | S Nat`. Suggested by Edward Kmett. Makes sense, because at highest level the GADT-ness is seldom needed.

----
= References =
  # http://www.iro.umontreal.ca/~monnier/comp-deptypes.pdf
  # [http://www.cs.uoregon.edu/research/summerschool/summer08/video/July26Lect1.wmv Tim Sheard's 2008 Lecture Video]
  # http://code.google.com/p/omega/source/browse/trunk/tests/Progress.prg
  # http://personal.cis.strath.ac.uk/~conor/pub/she/fun/talk.pdf

----
= Examples =

== Ωmega example for `‹‹Pat››` ==

`‹‹Pat››` is like `‹Nat›` but rooted under `*2`:
{{{
data Pat :: *2 where
  Y :: Pat
  Q :: Pat ~> Pat
 deriving Nat(p)

data Pat' :: Pat ~> *1 where
  Y' :: Pat' Y
  Q' :: Pat' n ~> Pat' (Q n)
 deriving Nat(q)

data Pat'' :: Pat' p ~> *0 where
  Y :: Pat'' Y'
  Q :: Pat'' n -> Pat'' (Q' n)
 deriving Nat(r)
}}}
We can see that all is pretty regular.

Testing:
{{{
prompt> Q (Q Y)
2r : Pat'' 2q
}}}

_Note: Issue 70 is hindering us rooting this under `*3`._

== Ωmega example for `‹‹plus››` ==

{{{
plus :: Pat ~> Pat ~> Pat
{plus Y n} = n
{plus (Q m) n} = Q {plus m n}

plus' :: Pat' m ~> Pat' n ~> Pat' {plus m n}
{plus' Y' n} = n
{plus' (Q' m) n} = Q' {plus' m n}

plus'' :: Pat'' m -> Pat'' n -> Pat'' {plus' m n}
plus'' Y n = n
plus'' (Q m) n = Q (plus'' m n)
}}}
Again, this is nice and regular.

_Note: unfortunately this does not compile with Ωmega 1.4.3 due to issue 23 :-(_

== Ωmega example for `«Foo»` ==

`«Foo»` has an isomorphic copy at every level up to infinity, we can tentatively sketch a definition here, not sure if the circularity is accepted:
{{{
data Foo :: level n . Foo ~> *n where
  Bar :: Foo
  Quux :: Foo ~> Foo
 deriving Nat(p)
}}}
Level 0 is standard.

_Note: it does not compile (with v1.4.6)_
`While parsing a type constructor, unknown type: Foo`