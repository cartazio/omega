#summary FÏ‰ lambda terms form a graph.
#labels Phase-Design

https://omega.googlecode.com/svn/wiki/LambdaGraph.svg

Key document: http://www.cs.gunma-u.ac.jp/~hamana/Papers/poly.pdf

I started implementing it here: https://code.google.com/p/omega/source/browse/mosaic/LambdaBuilder.hs

Some relevant packages:
  * http://hackage.haskell.org/package/compdata
  * http://hackage.haskell.org/package/regular
  * http://hackage.haskell.org/package/multirec

Some provide PHOAS-based finitely representable graphs.


= How it works =

... open up Adam Gundry's thesis ...

Each _lambda node_ is a portal where subgraphs are passed in by means of _application nodes_. Reference nodes (usually) point to one of these portals and mean: the subgraph that entered there. When a reference points to a non-binder, interesting semantics may arise, such as sharing, cycles etc.

== well-formed graphs ==

All references of the (full) graph are pointing at some node of the graph. When in the process of zipping, we have a partial graph in its surroundings, and each reference must be resolvable into either the partial graph or the surroundings.

== canonical references ==

References are canonical when they only point upwards. Binding references are canonical ones that point at lambda nodes. When all references in a (sub)graph are canonical, then the (sub)graph is canonical.

== `let` expressions ==

These are non-canonical graphs. When a reference ascends to an application node and descends to the left into a lambda node.

TODO: illustration

{{{(\up) @ up.left}}}

corresponds to {{{let a = a in a}}}

_Note: the middle `a` corresponds to the right branch of the application node._

== search tree ==

When the graph is either canonical, or all references have some `up` segments followed by a `left` segment. The rest is not relevant, but may not contain `up` segments.

All _previously mentioned_ subgraphs can be accessed this way. The search tree configuration thus is the most generic one, offering maximal sharing.


= Substitution =

Beta reduction happens by lifting the right application branch up a level, the left one up two levels, and than recursively inserting the pushed down right branch in the appropriate reference nodes of the left branch.

We need primitive movements for this.