#summary Fω lambda terms form a graph.
#labels Phase-Design

= Main Idea =

A graph representing (extended) lambda calculus terms is transformed into a _search tree_ and sharing, cycles, etc. are represented by (up`*`{down|left|right}`*`) references.

https://omega.googlecode.com/svn/wiki/LambdaGraph.svg

Key document: http://arxiv.org/pdf/1007.4266.pdf, but see also http://www.cs.gunma-u.ac.jp/~hamana/Papers/poly.pdf

I started implementing it here: https://code.google.com/p/omega/source/browse/mosaic/LambdaBuilder.hs

Some relevant packages:
  * http://hackage.haskell.org/package/compdata
  * http://hackage.haskell.org/package/regular
  * http://hackage.haskell.org/package/multirec

Some provide PHOAS-based finitely representable graphs.


= How it works =

... open up Adam Gundry's thesis ...

Each _lambda node_ is a portal where subgraphs are passed in by means of _application nodes_. Reference nodes (usually) point to one of these portals and mean: the subgraph that entered there. When a reference points to a non-binder, interesting semantics may arise, such as sharing, cycles etc.

== well-formed graphs ==

All references of the (full) graph are pointing at some node of the graph. When in the process of zipping, we have a partial graph in its surroundings, and each reference must be resolvable into either the partial graph or the surroundings.

== canonical references ==

References are canonical when they only point upwards. Binding references are canonical ones that point at lambda nodes. When all references in a (sub)graph are canonical, then the (sub)graph is canonical.

== `let` expressions ==

These are non-canonical graphs. When a reference ascends to an application node and descends to the left into a lambda node.

https://omega.googlecode.com/svn/wiki/Letrec.svg

{{{(λ{up}) @ {up.left}}}}

corresponds to (recursive) {{{let a = a in a}}}

_Note: the middle_ `a` _corresponds to the right branch of the application node._

== search tree ==

When the graph is either canonical, or all references have some `up` segments followed by a `left` segment. The rest is not relevant, but may not contain `up` segments.

All _previously mentioned_ subgraphs can be accessed this way. The search tree configuration thus is the most generic one, offering maximal sharing.


= Substitution =

Beta reduction happens by lifting the right application branch up a level, the left one up two levels, and than recursively inserting the pushed down right branch in the appropriate reference nodes of the left branch.

We need primitive movements (_steps_) for this.

== Step: `Down`, `Left`, `Right` ==

These are easy. Mark a _limit node_ and a _target node_ below it. Everything outside the cone of the former counts as the environment and references that point into the environment are _free_. These stretch.
Everything else remains the same.

TODO: illustrate

== Step: `Up` ==

This is hairy. Similarly we have our limit node and the target node in its cone. Free references are simply shortened by removing the initial `Up`. References that point into the cone of the target node do not change. Otherwise, ... (TODO: I need to think about this.)

== Movements ==

A coherent sequence of steps is a _movement_. These form a category.

Since primitive movements only affect _free references_ (those into the context) stream fusion like techniques could be applied to avoid multiple traversals of the tree.

= Notes =

There is only one binder (in the spirit of [http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=331521 Kamareddine, JFP 2005]) and by resorting to level inference, it can be recovered whether it is a π, λ or Λ.

Later there will be a ∑-like binder too. (Actually, ∑ is the same thing as π, only being _uncurried_, i.e. it has moved into the pattern).

The application node could come equipped with a natural number, signifying the number of iterated applications, i.e. S^n^Z, for constant `n`. Fixpoints can also be encoded by f @ {up}. In this case
non-zero `n` would collapse to `1`, and for `n=1` it would be a common loop.

So an application node with `n=0` would normally be eliminable, unless there are {up.left} etc. references in the right subgraph.

Iterated nodes are useful for finitary sharing, as type checking etc., can process the many iterations in bulk.

= More Interesting Papers =

http://gallium.inria.fr/~balabons/Recherche/Balabonski-ICFP13.pdf mentions the "sharing-via-labelling" technique.