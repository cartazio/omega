#summary A rather conservative avenue to type classes in Î©mega.
#labels speculative

= Introduction =

Section ??? of the User's Manual mentions that static propositions are propagated and discharged in the same way as class constraints in Haskell. This gives me the idea to actually *implement* type classes as `prop`.

But there is a dynamic (i.e. _value_) aspect to type classes too, namely the _dictionary_. C.f. the `Monad` datatype which carries the `return`, `bind`and `fail` functionalities for monads.

= Details =

We give a very speculative account of how this could work by the example of a `Num` class that allows us to treat `Int` and `Float` by common terms.

{{{
prop Class :: Tag ~> a ~> *1 where
  Inst :: Instance nam a => {dictionary nam a} ~> Class nam a
}}}

Now we have to define Instance as prop too and hook up
the (plus, negate, mul, div) tuple to the mix.

Superclass constraints?